/*
 * nanopi.c
 * @brief
 * Copyright Â© 2017 epsilonRT, All rights reserved.
 * This software is governed by the CeCILL license <http://www.cecill.info>
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/sysinfo.h>
#include <sysio/nanopi.h>

/* constants ================================================================ */
#if defined(BOARD_NANOPI_NEO)
#define NANOPI_MODEL eNanoPiModelNeo
#elif defined(BOARD_NANOPI_AIR)
#define NANOPI_MODEL eNanoPiModelNeoAir
#elif defined(BOARD_NANOPI_M1)
#define NANOPI_MODEL eNanoPiModelNeoM1
#elif defined(BOARD_NANOPI_M1PLUS)
#define NANOPI_MODEL eNanoPiModelNeoM1Plus
#elif defined(BOARD_NANOPI_NEO2)
#define NANOPI_MODEL eNanoPiModelNeo2
#elif defined(BOARD_NANOPI_NEOPLUS2)
#define NANOPI_MODEL eNanoPiModelNeoPlus2
#else
#error Unsupported or undefined nanopi card model
#endif

/* constants ================================================================ */
static const char sManFriendlyARM[] = "FriendlyARM";
static const char sUnknown[] = "Unknown";

static const char * sModelList[] = {
  "NanoPi Neo",
  "NanoPi Neo2",
  "NanoPi Neo Plus2",
  "NanoPi Neo Air",
  "NanoPi M1",
  "NanoPi M1 Plus",
};

static const char * sMcuList[] = {
  "Allwinner H3",
  "Allwinner H5"
};

/* private variables ======================================================== */
static eNanoPiModel eNpiBoard = eNanoPiModelUnknown;
static xNanoPi * pxNpi;
static xNanoPi xNpiDb[] = {

  { .eModel = eNanoPiModelNeo,      .iGpioRev = 1,  .eMcu = eNanoPiMcuH3,     .iMemMB = -1, .sManufacturer = sManFriendlyARM },
  { .eModel = eNanoPiModelNeo2,     .iGpioRev = 1,  .eMcu = eNanoPiMcuH5,     .iMemMB = -1, .sManufacturer = sManFriendlyARM },
  { .eModel = eNanoPiModelNeoPlus2, .iGpioRev = 1,  .eMcu = eNanoPiMcuH5,     .iMemMB = -1, .sManufacturer = sManFriendlyARM },
  { .eModel = eNanoPiModelNeoAir,   .iGpioRev = 1,  .eMcu = eNanoPiMcuH3,     .iMemMB = -1, .sManufacturer = sManFriendlyARM },
  { .eModel = eNanoPiModelNeoM1,    .iGpioRev = 2,  .eMcu = eNanoPiMcuH3,     .iMemMB = -1, .sManufacturer = sManFriendlyARM },
  { .eModel = eNanoPiModelNeoM1Plus,.iGpioRev = 3,  .eMcu = eNanoPiMcuH3,     .iMemMB = -1, .sManufacturer = sManFriendlyARM },
  /* Last element */
  { .eModel = eNanoPiModelUnknown, .iGpioRev = -1, .eMcu = eNanoPiMcuUnknown, .iMemMB = -1, .sManufacturer = sUnknown}
};

/* private functions ======================================================== */
static  char *
sGetParam (char * line,  char * param) {
  char * p;

  p = strstr (line, "=");
  if (p) {
    if (strlen (p) > 1) {

      return strstr (p + 1, param);
    }
  }
  return NULL;
}

/* internal public functions ================================================ */

/* -----------------------------------------------------------------------------
  $ cat /etc/armbian-release
  # PLEASE DO NOT EDIT THIS FILE
  BOARD=nanopineo
  BOARD_NAME="NanoPi Neo"
  VERSION=5.23
  LINUXFAMILY=sun8i
  BRANCH=default
  ARCH=arm
 */
eNanoPiModel
eNanoPiBoard (void) {

  if (eNpiBoard == eNanoPiModelUnknown) {
    FILE * fp = fopen ("/etc/armbian-release", "r");

    if (fp) {
      char *p, *value;
      char buffer[1024];

      while ( (p = fgets (buffer, sizeof (buffer), fp))) {
        value = sGetParam (p, "BOARD");

        if (value) {
          if (strcasecmp (value, "nanopineo") == 0) {
            eNpiBoard = eNanoPiModelNeo;
            break;
          }
          if (strcasecmp (value, "nanopineo2") == 0) {
            eNpiBoard = eNanoPiModelNeo2;
            break;
          }
          if (strcasecmp (value, "nanopineoplus2") == 0) {
            eNpiBoard = eNanoPiModelNeoPlus2;
            break;
          }
          else if (strcasecmp (value, "nanopineoair") == 0) {
            eNpiBoard = eNanoPiModelNeoAir;
            break;
          }
          else if (strcasecmp (value, "nanopim1") == 0) {
            eNpiBoard = eNanoPiModelNeoM1;
            break;
          }
          else if (strcasecmp (value, "nanopim1plus") == 0) {
            eNpiBoard = eNanoPiModelNeoM1Plus;
            break;
          }
        }
      }
      if (fclose (fp) < 0) {

        perror ("fclose");
      }
    }
    else {

      perror ("fopen");
    }
  }
  if (eNpiBoard == eNanoPiModelUnknown) {

    eNpiBoard = NANOPI_MODEL;
  }
  return eNpiBoard;
}

// -----------------------------------------------------------------------------
const xNanoPi *
pxNanoPiInfo (void) {

  if (pxNpi == NULL) {
    if (eNanoPiBoard() != eNanoPiModelUnknown) {
      struct sysinfo info;

      pxNpi = &xNpiDb[eNpiBoard];

      if (sysinfo (&info) == 0) {
        int roundram = 1;
        unsigned long totalram = (info.totalram * info.mem_unit) / (1024 * 1024);

        while (roundram < totalram) {

          roundram <<= 1;
        }
        pxNpi->iMemMB = roundram;
      }
    }
  }
  return pxNpi;
}

// -----------------------------------------------------------------------------
const char *
sNanoPiModelToStr (eNanoPiModel eModel) {

  if ( (eModel >= eNanoPiModelNeo) && (eModel <= eNanoPiModelNeoM1)) {

    return sModelList[eModel];
  }
  return sUnknown;
}

// -----------------------------------------------------------------------------
const char *
sNanoPiMcuToStr (eNanoPiMcu eMcu) {

  if ( (eMcu >= eNanoPiMcuH3) && (eMcu <= eNanoPiMcuH3)) {

    return sMcuList[eMcu];
  }
  return sUnknown;
}

/* ========================================================================== */
